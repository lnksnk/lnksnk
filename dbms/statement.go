package dbms

import (
	"context"
	"database/sql"
	"io"
	"strings"

	"github.com/lnksnk/lnksnk/fs"
	"github.com/lnksnk/lnksnk/iorw"
	"github.com/lnksnk/lnksnk/parameters"
)

type Result interface {
	// LastInsertId returns the integer generated by the database
	// in response to a command. Typically this will be from an
	// "auto increment" column when inserting a new row. Not all
	// databases support this feature, and the syntax of such
	// statements varies.
	LastInsertId() (int64, error)

	// RowsAffected returns the number of rows affected by an
	// update, insert, or delete. Not every database or database
	// driver may support this.
	RowsAffected() (int64, error)
}

type Statement interface {
	Query(...interface{}) (Reader, error)
	QueryContext(context.Context, ...interface{}) (Reader, error)
	Execute(...interface{}) (Result, error)
	ExecuteContext(context.Context, ...interface{}) (Result, error)
	Rows() Rows
	Close() error
}

type statement struct {
	dbcn *sql.DB
	//dbstmt   *sql.Stmt
	rows      Rows
	driver    string
	query     string
	fsys      fs.MultiFileSystem
	fireader  func(fs.MultiFileSystem, fs.FileInfo, io.Writer)
	params    parameters.ParametersAPI
	rdr       Reader
	rcrd      Record
	args      map[string]interface{}
	prssqlarg func(int) string
}

// Close implements Statement.
func (s *statement) Close() (err error) {
	if s == nil {
		return
	}
	rows := s.rows
	s.dbcn = nil
	s.rows = nil
	s.prssqlarg = nil
	args := s.args
	s.args = nil
	s.fireader = nil
	s.fsys = nil
	s.params = nil
	s.rdr = nil
	s.rcrd = nil
	if args != nil {
		clear(args)
		args = nil
	}

	if rows != nil {
		go rows.Close()
	}
	return
}

// Rows implements Statement.
func (s *statement) Rows() Rows {
	if s == nil {
		return nil
	}
	return s.rows
}

// Execute implements Statement.
func (s *statement) Execute(a ...interface{}) (result Result, err error) {
	if s == nil {
		return
	}
	return s.ExecuteContext(context.Background(), a...)
}

// ExecuteContext implements Statement.
func (s *statement) ExecuteContext(ctx context.Context, a ...interface{}) (result Result, err error) {
	if s == nil {
		return
	}
	if ctx == nil {
		ctx = context.Background()
		defer func() {
			ctx = nil
		}()
	}
	dbcn := s.dbcn
	if dbcn != nil {
		return dbcn.ExecContext(ctx, s.query, a...)
	}
	return
}

// Query implements Statement.
func (s *statement) Query(a ...interface{}) (rdr Reader, err error) {
	if s == nil {
		return
	}
	return s.QueryContext(context.Background(), a...)
}

// QueryContext implements Statement.
func (s *statement) QueryContext(ctx context.Context, a ...interface{}) (rdr Reader, err error) {
	if s == nil {
		return
	}
	if ctx == nil {
		ctx = context.Background()
		defer func() {
			ctx = nil
		}()
	}
	dbcn, rws := s.dbcn, s.rows
	if dbcn != nil {
		if rws == nil {
			dbrows, dbrowserr := dbcn.QueryContext(ctx, s.query, a...)
			if err = dbrowserr; err == nil {
				s.rows = &rows{IRows: &dbirows{dbrows: dbrows}}
				rdr = &reader{stmnt: s, rws: s.rows}
				return
			}
		}
		return
	}
	return
}

func prepairSqlStatement(s *statement, a ...interface{}) (prpdqry string, prpdargs []interface{}, err error) {
	if s == nil || s.prssqlarg == nil {
		return
	}
	//prssqlarg := s.prssqlarg
	params := s.params
	srdr := s.rdr
	args := s.args
	fireader := s.fireader
	rcrd := s.rcrd
	if al := len(a); al > 0 {
		ai := 0
		for ai < al {
			if prmsd, prmsk := a[ai].(parameters.ParametersAPI); prmsk {
				if params == nil && prmsd != nil {
					params = prmsd
					s.params = params
				}
				a = append(a[:ai], a[ai+1:]...)
				al--
				continue
			}
			if rdrd, rdrk := a[ai].(Reader); rdrk {
				if srdr == nil && rdrd != nil {
					srdr = rdrd
					s.rdr = srdr
				}
				a = append(a[:ai], a[ai+1:]...)
				al--
				continue
			}
			if rcrdd, rcrdk := a[ai].(Record); rcrdk {
				if rcrd == nil && rcrdd != nil {
					rcrd = rcrdd
					s.rcrd = rcrd
				}
				a = append(a[:ai], a[ai+1:]...)
				al--
				continue
			}
			if firdrd, firdrk := a[ai].(func(fs.MultiFileSystem, fs.FileInfo, io.Writer)); firdrk {
				if fireader == nil && firdrd != nil {
					fireader = firdrd
					s.fireader = fireader
				}
				a = append(a[:ai], a[ai+1:]...)
				al--
				continue
			}
			if argsd, argsk := a[ai].(map[string]string); argsk {
				if args == nil && len(argsd) > 0 {
					args = map[string]interface{}{}
					for ak, av := range argsd {
						args[ak] = av
					}
					s.args = args
				}
				a = append(a[:ai], a[ai+1:]...)
				al--
				continue
			}
			ai++
		}
	}
	qrybf := iorw.NewBuffer()
	defer qrybf.Close()
	if fsys := s.fsys; fsys != nil {
		s.fsys = nil
		tstquery := s.query
		tstext := func() string {
			if si := strings.LastIndex(tstquery, "."); si > 0 {
				if tstquery[si:] == ".sql" {
					tstquery = tstquery[:si]
					return ".sql"
				}
				return ".sql"
			}
			return ".sql"
		}()
		fi := fsys.Stat(tstquery + tstext)

		if fi == nil {
			fi = fsys.Stat(tstquery + "." + s.driver + tstext)
		}
		if fi != nil {
			if fireader != nil {
				fireader(fsys, fi, qrybf)
			} else {
				qrybf.Print(fi.Reader())
			}
		} else {
			qrybf.Print(s.query)
		}
	}

	return qrybf.String(), prpdargs, err
}

func nextstatement(dbcn *sql.DB, driver Driver, query string, fsys fs.MultiFileSystem) (stmnt Statement) {
	return &statement{dbcn: dbcn, driver: driver.Name(), prssqlarg: driver.ParseSqlArg, query: query, fsys: fsys}
}
