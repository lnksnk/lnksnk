package dbms

import (
	"context"
	"database/sql"
	"fmt"
	"io"
	"strings"

	"github.com/lnksnk/lnksnk/fs"
	"github.com/lnksnk/lnksnk/ioext"
	"github.com/lnksnk/lnksnk/parameters"
	"github.com/lnksnk/lnksnk/template"
)

type Result interface {
	// LastInsertId returns the integer generated by the database
	// in response to a command. Typically this will be from an
	// "auto increment" column when inserting a new row. Not all
	// databases support this feature, and the syntax of such
	// statements varies.
	LastInsertId() (int64, error)

	// RowsAffected returns the number of rows affected by an
	// update, insert, or delete. Not every database or database
	// driver may support this.
	RowsAffected() (int64, error)
}

type Statement interface {
	Query(...interface{}) (Reader, error)
	QueryContext(context.Context, ...interface{}) (Reader, error)
	Execute(...interface{}) (Result, error)
	ExecuteContext(context.Context, ...interface{}) (Result, error)
	Rows() Rows
	Close() error
}

type statement struct {
	db   *sql.DB
	dbcn *sql.Conn
	//dbstmt   *sql.Stmt
	rows      Rows
	driver    string
	initquery string
	query     []string
	queryargs map[int][]interface{}
	fsys      fs.MultiFileSystem
	fireader  func(fs.MultiFileSystem, fs.FileInfo, io.Writer)
	params    parameters.Parameters
	rdr       Reader
	rcrd      Record
	args      map[string]interface{}
	prssqlarg func(int) string
}

// Close implements Statement.
func (s *statement) Close() (err error) {
	if s == nil {
		return
	}
	rows := s.rows
	dbcn := s.dbcn
	s.query = nil
	s.db = nil
	s.dbcn = nil
	s.rows = nil
	s.prssqlarg = nil
	args := s.args
	s.args = nil
	s.fireader = nil
	s.fsys = nil
	s.params = nil
	s.rdr = nil
	s.rcrd = nil
	queryargs := s.queryargs
	if args != nil {
		clear(args)
		args = nil
	}
	if queryargs != nil {
		clear(queryargs)
	}

	if rows != nil {
		go rows.Close()
	}
	if dbcn != nil {
		go dbcn.Close()
	}
	return
}

// Rows implements Statement.
func (s *statement) Rows() Rows {
	if s == nil {
		return nil
	}
	return s.rows
}

// Execute implements Statement.
func (s *statement) Execute(a ...interface{}) (result Result, err error) {
	if s == nil {
		return
	}
	return s.ExecuteContext(context.Background(), a...)
}

// ExecuteContext implements Statement.
func (s *statement) ExecuteContext(ctx context.Context, a ...interface{}) (result Result, err error) {
	if s == nil {
		return
	}
	if ctx == nil {
		ctx = context.Background()
		defer func() {
			ctx = nil
		}()
	}
	dbcn := s.dbcn
	if dbcn != nil {
		qryl, query := len(s.query), s.query
		if qryl == 1 {
			return dbcn.ExecContext(ctx, query[0], a...)
		}

	}
	return
}

// Query implements Statement.
func (s *statement) Query(a ...interface{}) (rdr Reader, err error) {
	if s == nil {
		return
	}
	return s.QueryContext(context.Background(), a...)
}

// QueryContext implements Statement.
func (s *statement) QueryContext(ctx context.Context, a ...interface{}) (rdr Reader, err error) {
	if s == nil {
		return
	}
	if ctx == nil {
		ctx = context.Background()
		defer func() {
			ctx = nil
		}()
	}
	db, dbcn, rws := s.db, s.dbcn, s.rows
	if db != nil || dbcn != nil {
		if rws == nil {
			qryl, query, queryargs := len(s.query), s.query, s.queryargs
			if qryl == 0 && s.initquery != "" {
				query = append(query, s.initquery)
				s.query = query
				qryl++
			}
			if qryl == 1 {
				if db != nil {
					dbrows, dbrowserr := db.QueryContext(ctx, query[0], func() []interface{} {
						if len(queryargs) > 0 {
							if qargs, qragsk := queryargs[0]; qragsk {
								return qargs
							}
						}
						return nil
					}()...)
					if err = dbrowserr; err == nil {
						s.rows = &rows{IRows: &dbirows{dbrows: dbrows}}
						rdr = &reader{stmnt: s, rws: s.rows}
					}
					return
				}
				if dbcn != nil {
					dbrows, dbrowserr := dbcn.QueryContext(ctx, query[0], func() []interface{} {
						if len(queryargs) > 0 {
							if qargs, qragsk := queryargs[0]; qragsk {
								return qargs
							}
						}
						return nil
					}()...)
					if err = dbrowserr; err == nil {
						s.rows = &rows{IRows: &dbirows{dbrows: dbrows}}
						rdr = &reader{stmnt: s, rws: s.rows}
					}
				}
				return
			}
			if dbcn != nil {
				var exeargs []interface{}
				var qryargs []interface{}
				if len(queryargs) > 0 {
					for qryn := range qryl {
						if len(queryargs[qryn]) == 0 {
							continue
						}
						if qrags, qragsk := queryargs[qryn]; qragsk {
							if qryn < qryl-1 {
								exeargs = append(exeargs, qrags...)
								continue
							}
							qryargs = append(qryargs, qrags...)
						}
					}
				}
				_, exeerr := dbcn.ExecContext(ctx, strings.Join(query[:qryl-1], ""), exeargs...)
				if err = exeerr; err != nil {
					return
				}

				dbrows, dbrowserr := dbcn.QueryContext(ctx, query[qryl-1], qryargs...)
				if err = dbrowserr; err != nil {
					return
				}
				if dbrows != nil {
					s.rows = &rows{IRows: &dbirows{dbrows: dbrows}}
					rdr = &reader{stmnt: s, rws: s.rows}
				}
				return
			}
		}
		return
	}
	return
}

func prepairSqlStatement(s *statement, a ...interface{}) (prpdqry []string, prpdargs map[int][]interface{}, err error) {
	if s == nil || s.prssqlarg == nil {
		return
	}
	//prssqlarg := s.prssqlarg
	params := s.params
	srdr := s.rdr
	args := s.args
	fireader := s.fireader
	rcrd := s.rcrd
	dfltargs := map[string]interface{}{}
	if al := len(a); al > 0 {
		ai := 0
		for ai < al {
			if prmsd, prmsk := a[ai].(parameters.Parameters); prmsk {
				if params == nil && prmsd != nil {
					params = prmsd
					s.params = params
				}
				a = append(a[:ai], a[ai+1:]...)
				al--
				continue
			}
			if rdrd, rdrk := a[ai].(Reader); rdrk {
				if srdr == nil && rdrd != nil {
					srdr = rdrd
					s.rdr = srdr
				}
				a = append(a[:ai], a[ai+1:]...)
				al--
				continue
			}
			if rcrdd, rcrdk := a[ai].(Record); rcrdk {
				if rcrd == nil && rcrdd != nil {
					rcrd = rcrdd
					s.rcrd = rcrd
				}
				a = append(a[:ai], a[ai+1:]...)
				al--
				continue
			}
			if firdrd, firdrk := a[ai].(func(fs.MultiFileSystem, fs.FileInfo, io.Writer)); firdrk {
				if fireader == nil && firdrd != nil {
					fireader = firdrd
					s.fireader = fireader
				}
				a = append(a[:ai], a[ai+1:]...)
				al--
				continue
			}
			if argsd, argsk := a[ai].(map[string]string); argsk {
				if args == nil && len(argsd) > 0 {
					args = map[string]interface{}{}
					for ak, av := range argsd {
						args[ak] = av
						dfltargs[strings.ToUpper(ak)] = av
					}
					s.args = args
				}
				a = append(a[:ai], a[ai+1:]...)
				al--
				continue
			}
			if argd, argk := a[ai].(map[string]interface{}); argk {
				if args == nil && len(argd) > 0 {
					args = map[string]interface{}{}
					for ak, av := range argd {
						args[ak] = av
						dfltargs[strings.ToUpper(ak)] = av
					}
					s.args = args
				}
				a = append(a[:ai], a[ai+1:]...)
				al--
				continue
			}
			ai++
		}
	}
	qrybf := ioext.NewBuffer()
	defer qrybf.Close()
	if fsys := s.fsys; fsys != nil {
		s.fsys = nil
		tstquery := s.initquery
		tstext := func() string {
			if si := strings.LastIndex(tstquery, "."); si > 0 {
				if tstquery[si:] == ".sql" {
					tstquery = tstquery[:si]
					return ".sql"
				}
				return ".sql"
			}
			return ".sql"
		}()
		fi := fsys.Stat(tstquery + tstext)

		if fi == nil {
			fi = fsys.Stat(tstquery + "." + s.driver + tstext)
		}
		if fi != nil {
			if fireader != nil {
				fireader(fsys, fi, qrybf)
			} else {
				qrybf.Print(fi.Reader())
			}
		} else {
			qrybf.Print(s.initquery)
		}
	}

	if qrybf.Contains("@") || qrybf.Contains(";") {
		var prsng *template.Parsing = nil
		orgrqry := func(yld func(rune) bool) {
			rdr := qrybf.Clone(true).Reader(true)
			defer rdr.Close()
			rdrrune := rdr.ReadRune
			for {
				rn, rs, rerr := rdrrune()
				if rs > 0 {
					if !yld(rn) {
						return
					}
				}
				if rerr != nil {
					return
				}
			}
		}

		var prmnme []rune
		var prmargvalsfnd = map[int]func() interface{}{}
		var prmargsfnd = []int{}
		prsng = template.New(nil, "@", "@", false, false, nil, func(prerns ...rune) {
			qrybf.WriteRunes(prerns...)
		}, nil, nil, func(canreset bool, rns ...rune) (reset bool) {
			prmnme = append(prmnme, rns...)
			return
		}, func() (reset bool) {
			//check param
			if len(prmnme) > 0 {
				tstnme := strings.TrimFunc(string(prmnme), ioext.IsSpace)
				if tstnme == "" {
					return
				}
				if params := s.params; params != nil {
					for _, pnme := range params.Keys() {
						if strings.EqualFold(pnme, tstnme) {
							prmfndl := len(prmargsfnd)
							prmargsfnd = append(prmargsfnd, prmfndl)
							dflsv, dflsk := dfltargs[strings.ToUpper(pnme)]
							prmargvalsfnd[prmfndl] = func() interface{} {
								prmsv := params.Get(pnme)
								if len(prmsv) == 0 {
									if dflsk {
										s, _ := dflsv.(string)
										return s
									}
									return ""
								}
								prmsvs := strings.Join(params.Get(pnme), "")
								if prmsvs == "" {
									if dflsk {
										s, _ := dflsv.(string)
										return s
									}
								}
								return prmsvs
							}
							qrybf.Print(s.prssqlarg(prmfndl))
							prmnme = nil
							return
						}
					}
				}

				if rows := s.rows; rows != nil {
					cols, colserr := rows.Columns()
					if err = colserr; err != nil {
						return
					}
					if len(cols) > 0 {
						if data := rows.Data(); len(data) == len(cols) {
							for cn, col := range cols {
								if strings.EqualFold(tstnme, col) {
									prmfndl := len(prmargsfnd)
									prmargsfnd = append(prmargsfnd, prmfndl)
									prmnme = nil
									dflsv, dflsk := dfltargs[strings.ToUpper(col)]
									prmargvalsfnd[prmfndl] = func() interface{} {
										dv := data[cn]
										if dvs, dvsk := dv.(string); dvsk {
											if dvs == "" {
												dvs, _ = dflsv.(string)
											}
											return dvs
										}
										if dv == nil {
											if dflsk {
												dv = dflsv
											}
										}
										return dv
									}
									qrybf.Print(s.prssqlarg(prmfndl))
									return
								}
							}
						}
					}
				}

				if dflsv, dflsk := dfltargs[strings.ToUpper(tstnme)]; dflsk {
					prmfndl := len(prmargsfnd)
					prmargsfnd = append(prmargsfnd, prmfndl)
					prmargvalsfnd[prmfndl] = func() interface{} {
						return dflsv
					}
					qrybf.Print(s.prssqlarg(prmfndl))
					prmnme = nil
					return
				}
				qrybf.Print(`null`)
				prmnme = nil
			}
			return
		})

		for or := range orgrqry {
			if or == ';' {
				prds := qrybf.Clone(true).Reader(true).SubString(0)
				if prds != "" {
					prds += ";"
					prpdqry = append(prpdqry, prds)
					if fndl := len(prmargsfnd); fndl > 0 {
						prpargsi := len(prpdqry) - 1
						if prpdargs == nil {
							prpdargs = map[int][]interface{}{}
						}
						prpdargs[prpargsi] = make([]interface{}, fndl)
						for fn, ids := range prmargsfnd {
							prpdargs[prpargsi][fn] = prmargvalsfnd[ids]()
						}
						prmargsfnd = nil
					}
				}
				continue
			}
			prsng.Parse(or)
		}
		if prsng != nil && prsng.Busy() {
			err = fmt.Errorf("%s", "failed parsing query arguments")
			return
		}
		fndl := len(prmargsfnd)
		if fndl > 0 {
			prpargsi := len(prpdqry)
			if prpdargs == nil {
				prpdargs = map[int][]interface{}{}
			}
			prpdargs[prpargsi] = make([]interface{}, fndl)
			for fn, ids := range prmargsfnd {
				prpdargs[prpargsi][fn] = prmargvalsfnd[ids]()
			}
			prmargsfnd = nil
		}
	}
	if !qrybf.Empty() {
		if prds := qrybf.Reader(true).SubString(0); prds != "" && prds != ";" {
			prpdqry = append(prpdqry, prds)
		}
	}

	return prpdqry, prpdargs, err
}

func nextstatement(db *sql.DB, driver Driver, query string, fsys fs.MultiFileSystem, a ...interface{}) (s *statement, err error) {
	if fsys == nil {
		if driver != nil {
			fsys = driver.FSys()
		}
	}

	if driver != nil {
		if driver.Name() != "csv" && driver.Name() != "dlv" {
			dbcn, dbconerr := db.Conn(context.Background())
			if err = dbconerr; dbconerr != nil {
				return
			}
			s = &statement{dbcn: dbcn, driver: driver.Name(), prssqlarg: driver.ParseSqlArg, initquery: query, fsys: fsys}
			s.query, s.queryargs, err = prepairSqlStatement(s, a...)
			if err != nil {
				s.Close()
				s = nil
				return
			}
			return
		}
		if dvrfsys := driver.FSys(); dvrfsys != nil {
			s = &statement{db: db, driver: driver.Name(), prssqlarg: driver.ParseSqlArg, initquery: query, fsys: fsys}
			s.query = append(s.query, s.initquery)
			queryargs := s.queryargs
			if queryargs == nil {
				s.queryargs = map[int][]interface{}{}
				queryargs = s.queryargs
			}
			queryargs[len(s.query)-1] = append(a, dvrfsys)
		}
	}
	return
}
